TODO:
=====

 * Scrum:
   
   Use scrum.

 * Commanline Module:
   
   Create a commandline module which resembles the mercurials "hg" command to
   let the users to manage their assets and data. Examples: stalker create
   project "Deneme". Also, to let the users easily use the commandline tool
   all the models should be easy to create.
 
 * Back References:
   
   All the attributes that has a back reference on other objects should reset
   the back reference value to Null or to the default value whenever they are
   set to None or empty list. For example, when the Project objects sequences
   attribute is set to an empty list or None, the referring Sequence objects
   project attribute should also be set to None, also there are tons of this
   kind of relations in the system. SQLAlchemy handles them automatically but
   Stalker should do it too, to allow others who are not willing to use
   SQLAlchemy as their ORM to be able to have this property automatically.

 * SCM Integration:
   
   The repository can be a local path, and the project can be managed with an
   SCM, preferably with Mercurial.

 * Unicode:
   
   All the string attributes should be unicode so for string attributes which
   are checked against being a string should now be checked agains being
   unicode.

 * Start & End Date For Classes Mixed With TaskMixin:
   
   All the classes which are mixed with TaskMixin should have a start and end
   date attribute which will be set to the start date of the first task to the
   due_date of the last task.

 * datetime instead of date
   
   In the Task class all the time calculation should be done over the
   datetime.datetime class instead of datetime.date object. This will let us
   to increase the granularity of the scheduling.

DONE:
=====

 * "__stalker_version__" in SimpleEntity:
   
   Create an attribute called __stalker_version__ in the SimpleEntity, and
   automatically update it to the current version string of Stalker to be able
   to see with which version of Stalker this data is created, mainly important
   for the database part.

 * Replace all the Mocker based tests with Unittest's which are using real
   objects. It was necessary to use the Mocker library while designing the rest
   of the system, but it is now making things complex and started to hide the
   changes of one object from the others in the system.

 * Convert all the list comparison test to assertItemsEqual

 * Add a slot in the ValidatedList which will hold the callable for the
   validation process when any of the objects are changed (set, remove, delete
   etc.) to allow the callable to be called when something has changed. This
   will allow more control on the list, e.g. this will help controling the
   relation of the classes to each other.

 * Check FilenameTemplate class documentation.

 * Check database part of all the previous Type dependent classes (Link, Asset,
   Project, Task)

 * Update the exceptions. Check if a proper exception is raised instead of
   raising ValueErrors all the time.

 * A Status in StatusList should be accessed by its name used as the index
 
 * A status should be comparable with a string like project.status=="complete"
   or project.status=="cmplt"
 
 * for an object which stores a list of other objects, stalker is validating if
   the list is gathered from the correct type of objects, for example,
   StatusList objects only accepts a list of Status objects. Stalker is able to
   check if the elements in a list are Status objects when a list is assigned
   to the StatusList.statuses attribute, but it can not check anything if the
   list element is changed individually afterwards. This behaviour should be
   extended with a validating system which is able to track changes on list
   elements.
   
   SOLUTION:
     
     Added the ValidatedList list variant which does all the necessary things
     explained in the problem.
